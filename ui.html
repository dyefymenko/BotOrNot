<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BOT or NOT?</title>
  <style>
    :root {
      --primary: #6e00ff;
      --secondary: #00e5ff;
      --accent: #ff2a6d;
      --background: #0a0a1a;
      --light: #ffffff;
      --dark: #121225;
      --success: #05ffa1;
      --warning: #ffd166;
      --danger: #ff5e5b;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    body {
      background-color: var(--background);
      color: var(--light);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    
    header {
      text-align: center;
      margin-bottom: 40px;
      padding-top: 20px;
    }
    
    .logo {
      font-size: 3.5rem;
      font-weight: 900;
      letter-spacing: -1px;
      margin-bottom: 10px;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 20px rgba(110, 0, 255, 0.3);
    }
    
    .tagline {
      font-size: 1.2rem;
      color: var(--secondary);
      opacity: 0.8;
    }

    /* Views/Screens */
    .view {
      display: none;
    }
    
    .view.active {
      display: block;
    }
    
    /* Join Game View */
    .entry-options {
      display: flex;
      gap: 30px;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 30px;
    }
    
    .option-card {
      background: var(--dark);
      border-radius: 16px;
      padding: 30px;
      width: 320px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
      text-align: center;
      border: 2px solid transparent;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .option-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, var(--primary), var(--secondary));
      opacity: 0;
      z-index: -1;
      transition: opacity 0.3s ease;
    }
    
    .option-card:hover {
      transform: translateY(-5px);
      border-color: var(--secondary);
    }
    
    .option-card h2 {
      font-size: 1.8rem;
      margin-bottom: 15px;
      position: relative;
    }
    
    .option-card p {
      margin-bottom: 25px;
      color: var(--light);
      opacity: 0.7;
      line-height: 1.5;
    }
    
    .human-card h2 {
      color: var(--success);
    }
    
    .bot-card h2 {
      color: var(--accent);
    }
    
    .btn {
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      color: var(--light);
      border: none;
      padding: 12px 25px;
      border-radius: 30px;
      font-weight: bold;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      z-index: 1;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--primary));
      transition: width 0.3s ease;
      z-index: -1;
    }
    
    .btn:hover::before {
      width: 100%;
    }
    
    .btn:hover {
      box-shadow: 0 5px 15px rgba(110, 0, 255, 0.4);
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    .btn:disabled:hover::before {
      width: 0;
    }
    
    /* Game Info Panel */
    .game-info {
      background: rgba(18, 18, 37, 0.6);
      border-radius: 16px;
      padding: 30px;
      width: 100%;
      max-width: 800px;
      margin: 20px auto;
      border: 1px solid rgba(110, 0, 255, 0.2);
    }
    
    .info-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .prize-pool {
      font-size: 1.8rem;
      font-weight: bold;
      color: var(--success);
    }
    
    .timer {
      font-size: 1.8rem;
      font-weight: bold;
      color: var(--warning);
    }
    
    /* Connection Status Indicator */
    .connection-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 5px 10px;
      border-radius: 20px;
      font-size: 0.8rem;
      z-index: 100;
    }
    
    .connection-status.online {
      background-color: var(--success);
      color: var(--dark);
    }
    
    .connection-status.offline {
      background-color: var(--danger);
      color: var(--light);
    }
    
    .connection-status.connecting {
      background-color: var(--warning);
      color: var(--dark);
    }
    
    /* Late-joiner notification */
    .late-join-notification {
      background: rgba(255, 42, 109, 0.1);
      border: 1px solid var(--accent);
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 20px;
      text-align: center;
      animation: pulse 2s infinite;
    }
    
    /* Waiting Room */
    .waiting-status {
      text-align: center;
      margin: 20px 0;
      font-size: 1.5rem;
      color: var(--secondary);
    }
    
    .players-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 15px;
      margin-top: 20px;
    }
    
    .player-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
      transition: all 0.2s ease;
    }
    
    .player-card:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: scale(1.03);
    }
    
    .player-card.you {
      border: 2px solid var(--accent);
    }
    
    .avatar {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      margin: 0 auto 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      font-weight: bold;
      background: linear-gradient(45deg, var(--primary), var(--secondary));
    }
    
    .player-name {
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .player-type {
      font-size: 0.8rem;
      opacity: 0.7;
    }
    
    .vote-btn {
      background: transparent;
      border: 1px solid var(--accent);
      color: var(--accent);
      padding: 5px 10px;
      border-radius: 20px;
      margin-top: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.8rem;
    }
    
    .vote-btn:hover, .vote-btn.selected {
      background: var(--accent);
      color: var(--light);
    }
    
    /* Chat Room */
    .chat-container {
      display: flex;
      flex-direction: column;
      height: 500px;
      background: rgba(18, 18, 37, 0.6);
      border-radius: 16px;
      padding: 20px;
      width: 100%;
      max-width: 800px;
      margin: 20px auto;
      border: 1px solid rgba(110, 0, 255, 0.2);
    }
    
    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .chat-messages {
      flex-grow: 1;
      overflow-y: auto;
      margin-bottom: 15px;
      padding: 10px;
    }
    
    .message {
      margin-bottom: 15px;
      display: flex;
      align-items: flex-start;
    }
    
    .message-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin-right: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      font-weight: bold;
      flex-shrink: 0;
    }
    
    .message-content {
      background: rgba(255, 255, 255, 0.05);
      padding: 10px 15px;
      border-radius: 18px;
      max-width: 80%;
    }
    
    .message-sender {
      font-weight: bold;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
    }
    
    .message-sender .you-badge {
      background-color: var(--accent);
      color: var(--light);
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 10px;
      margin-left: 6px;
    }
    
    .message-text {
      line-height: 1.4;
    }
    
    .chat-input {
      display: flex;
      gap: 10px;
    }
    
    .chat-input input {
      flex-grow: 1;
      padding: 12px;
      border-radius: 30px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: var(--light);
      font-size: 1rem;
    }
    
    .send-btn {
      background: var(--primary);
      color: var(--light);
      border: none;
      padding: 0 20px;
      border-radius: 30px;
      font-weight: bold;
      cursor: pointer;
    }
    
    /* Voting Screen */
    .voting-container {
      text-align: center;
      max-width: 800px;
      margin: 0 auto;
    }
    
    .voting-title {
      font-size: 2rem;
      margin-bottom: 20px;
      color: var(--accent);
    }
    
    .voting-subtitle {
      font-size: 1.2rem;
      margin-bottom: 30px;
      color: var(--light);
      opacity: 0.8;
    }
    
    /* Results Screen */
    .results-container {
      text-align: center;
      max-width: 800px;
      margin: 0 auto;
    }
    
    .results-title {
      font-size: 2rem;
      margin-bottom: 20px;
      color: var(--secondary);
    }
    
    .results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 20px;
      margin: 30px 0;
    }
    
    .result-card {
      background: rgba(18, 18, 37, 0.8);
      border-radius: 16px;
      padding: 20px;
      position: relative;
      overflow: hidden;
    }
    
    .result-card.bot {
      border: 2px solid var(--accent);
    }
    
    .result-card.human {
      border: 2px solid var(--success);
    }
    
    .result-card.you {
      box-shadow: 0 0 15px var(--primary);
    }
    
    .result-label {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 0.8rem;
      font-weight: bold;
    }
    
    .result-label.bot {
      background: var(--accent);
      color: var(--light);
    }
    
    .result-label.human {
      background: var(--success);
      color: var(--dark);
    }
    
    .votes-count {
      margin-top: 15px;
      font-size: 1.2rem;
    }
    
    .play-again-btn {
      margin-top: 30px;
    }

    .most-voted {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 0.8rem;
      font-weight: bold;
      background: var(--warning);
      color: var(--dark);
    }

    .success-btn {
      background: linear-gradient(90deg, var(--success), var(--secondary)) !important;
    }
    
    /* Modal */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .modal.active {
      opacity: 1;
      pointer-events: all;
    }
    
    .modal-content {
      background: var(--dark);
      border-radius: 16px;
      padding: 30px;
      width: 90%;
      max-width: 500px;
      text-align: center;
      position: relative;
      border: 2px solid var(--primary);
    }
    
    .close-modal {
      position: absolute;
      top: 15px;
      right: 15px;
      background: none;
      border: none;
      color: var(--light);
      font-size: 1.5rem;
      cursor: pointer;
    }
    
    .modal h2 {
      font-size: 2rem;
      margin-bottom: 20px;
      color: var(--secondary);
    }
    
    .input-group {
      margin-bottom: 20px;
    }
    
    .input-group label {
      display: block;
      margin-bottom: 8px;
      text-align: left;
      color: var(--light);
      opacity: 0.8;
    }
    
    .input-group input {
      width: 100%;
      padding: 12px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: var(--light);
      font-size: 1rem;
    }
    
    .submit-btn {
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      color: var(--light);
      border: none;
      padding: 12px 25px;
      border-radius: 30px;
      font-weight: bold;
      font-size: 1rem;
      cursor: pointer;
      width: 100%;
      margin-top: 10px;
    }
    
    .footer {
      text-align: center;
      margin-top: auto;
      padding: 20px;
      opacity: 0.7;
      font-size: 0.9rem;
    }
    
    /* Animations */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .pulse {
      animation: pulse 2s infinite;
    }

    /* Progress bar */
    .progress-container {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 30px;
      height: 10px;
      width: 100%;
      margin: 20px 0;
      overflow: hidden;
    }
    
    .progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      border-radius: 30px;
      transition: width 0.5s ease;
    }
    
    /* User stats */
    .user-stats {
      background: rgba(18, 18, 37, 0.6);
      border-radius: 10px;
      padding: 15px;
      margin-top: 20px;
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
    }

    .spacer {
  width: 20px; /* Width of the space you want */
  display: inline-block;
}
    
    .stat-item {
      text-align: center;
      padding: 10px;
    }
    
    .stat-value {
      font-size: 1.8rem;
      font-weight: bold;
      color: var(--secondary);
    }
    
    .stat-label {
      font-size: 0.9rem;
      opacity: 0.7;
    }
    
    /* Toast notifications */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
    }
    
    .toast {
      background: var(--dark);
      color: var(--light);
      border-radius: 8px;
      padding: 15px 20px;
      margin-top: 10px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: center;
      transform: translateX(120%);
      transition: transform 0.3s ease;
    }
    
    .toast.show {
      transform: translateX(0);
    }
    
    .toast.info {
      border-left: 4px solid var(--secondary);
    }
    
    .toast.success {
      border-left: 4px solid var(--success);
    }
    
    .toast.warning {
      border-left: 4px solid var(--warning);
    }
    
    .toast.error {
      border-left: 4px solid var(--danger);
    }
    
    .toast-close {
      background: none;
      border: none;
      color: var(--light);
      margin-left: 10px;
      cursor: pointer;
      opacity: 0.7;
    }
    
    .toast-close:hover {
      opacity: 1;
    }
    
    @media (max-width: 768px) {
      .logo {
        font-size: 2.5rem;
      }
      
      .option-card {
        width: 100%;
      }
      
      .chat-container {
        height: 400px;
      }
    }
  </style>
</head>
<body>
  <!-- Connection Status Indicator -->
  <div class="connection-status connecting" id="connectionStatus">
    Connecting...
  </div>
  
  <!-- Toast Notifications -->
  <div class="toast-container" id="toastContainer"></div>
  
  <div class="container">
    <header>
      <h1 class="logo">BOT or NOT?</h1>
      <p class="tagline">A social deduction game of trust and deception</p>
    </header>
    
    <!-- JOIN GAME VIEW -->
    <div id="joinView" class="view active">
      <div class="entry-options">
        <div class="option-card human-card">
          <h2>JOIN GAME</h2>
          <p>Enter the game and try to identify which player is controlled by an AI. One random player will have an AI agent chat on their behalf.</p>
          <button class="btn" onclick="openModal('human')">JOIN GAME</button>
        </div>
      </div>
      
      <div class="game-info">
        <div class="info-header">
          <div class="prize-pool">Prize Pool: <span id="prizePoolAmount">230</span> USDC</div>
          <div class="spacer"></div>
          <div class="timer" id="nextGameTimer">Next Game: 03:42</div>
        </div>
        
        <h3>Upcoming Game: #<span id="upcomingGameId">4281</span></h3>
        <p><span id="lobbyPlayerCount">23</span> players waiting • Join now to secure your spot</p>
        
        <div class="players-grid" id="lobbyPlayers">
          <!-- Player cards will be dynamically generated -->
        </div>
      </div>
    </div>
    
    <!-- WAITING ROOM VIEW -->
    <div id="waitingView" class="view">
      <div id="lateJoinNotification" class="late-join-notification" style="display:none;">
        <p>A game is already in progress! You'll be added to the next game starting in <span id="nextGameCountdown">00:00</span>.</p>
      </div>
      
      <div class="game-info">
        <div class="info-header">
          <div class="prize-pool">Prize Pool: <span id="waitingPrizePool">230</span> USDC</div>
          <div class="spacer"></div>
          <div class="timer" id="waitingTimer">Starting in: 01:00</div>
        </div>
        
        <h3>Game #<span id="waitingGameId">4281</span> Waiting Room</h3>
        <p class="waiting-status" id="waitingStatus">Waiting for game to start...</p>
        
        <div class="progress-container">
          <div class="progress-bar" id="waitingProgress" style="width: 0%"></div>
        </div>
        
        <p><span id="waitingPlayerCount">24</span> players in lobby</p>
        
        <div class="players-grid" id="waitingPlayers">
          <!-- Player cards will be added dynamically -->
        </div>
      </div>
    </div>
    
    <!-- CHAT ROOM VIEW -->
    <div id="chatView" class="view">
      <div class="chat-container">
        <div class="chat-header">
          <h3>Game #<span id="chatGameId">4281</span> Chat Room</h3>
          <div class="timer" id="chatTimer">Time left: 01:00</div>
        </div>
        
        <div class="progress-container">
          <div class="progress-bar" id="chatProgress" style="width: 100%"></div>
        </div>
        
        <div class="chat-messages" id="chatMessages">
          <!-- Messages will be added dynamically -->
        </div>
        
        <div class="chat-input">
          <input type="text" id="messageInput" placeholder="Type your message here..." />
          <button class="send-btn" onclick="sendMessage()">Send</button>
        </div>
      </div>
      
      <p class="waiting-status">Chat with other players! Can you identify who's human and who's a bot?</p>
      
      <div class="game-info">
        <h3>Current Players</h3>
        <div class="players-grid" id="currentPlayers">
          <!-- Player cards will be added dynamically -->
        </div>
      </div>
    </div>
    
    <!-- VOTING VIEW -->
    <div id="votingView" class="view">
      <div class="voting-container">
        <h2 class="voting-title">Time to Vote!</h2>
        <p class="voting-subtitle">Select the player you think is an AI bot</p>
        
        <div class="timer" id="votingTimer">Time left: 00:10</div>
        
        <div class="progress-container">
          <div class="progress-bar" id="votingProgress" style="width: 100%"></div>
        </div>
        
        <div class="players-grid" id="votingPlayers">
          <!-- Player cards with voting buttons will be added dynamically -->
        </div>
      </div>
    </div>
    
    <!-- RESULTS VIEW -->
    <div id="resultsView" class="view">
      <div class="results-container">
        <h2 class="results-title">Game Results</h2>
        <p class="voting-subtitle">Let's see who was right!</p>
        
        <div class="results-grid" id="resultsGrid">
          <!-- Results will be added dynamically -->
        </div>
        
        <div class="user-stats">
          <div class="stat-item">
            <div class="stat-value" id="playerEarnings">0</div>
            <div class="stat-label">USDC Earned</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="playerWinRate">0%</div>
            <div class="stat-label">Win Rate</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="playerGamesPlayed">0</div>
            <div class="stat-label">Games Played</div>
          </div>
        </div>
        
        <button class="btn play-again-btn" onclick="playAgain()">Play Again</button>
      </div>
    </div>
  </div>
  
  <!-- MODALS -->
  <div class="modal" id="humanModal">
    <div class="modal-content">
      <button class="close-modal" onclick="closeModal('human')">×</button>
      <h2>Join Game</h2>
      <form id="humanForm">
        <div class="input-group">
          <label for="username">Choose a Username</label>
          <input type="text" id="username" placeholder="Your display name" required>
        </div>
        
        <div class="input-group">
          <label for="promptText">Your AI Agent Prompt (In case you're selected)</label>
          <input type="text" id="promptText" placeholder="e.g., A witty 60-year-old history professor who loves puns" required>
        </div>
        
        <div class="input-group">
          <label for="wallet">Your Wallet Address</label>
          <input type="text" id="wallet" placeholder="0x..." value="0x742d35Cc6634C0532925a3b844Bc454e4438f44e">
        </div>
        
        <button type="button" class="submit-btn" onclick="joinGame('human')">JOIN GAME</button>
      </form>
    </div>
  </div>
  
  <footer class="footer">
    <p>© 2025 HUMAN or BOT? — Play to win, trust no one.</p>
  </footer>
  
  <script>
    // Game state - centralized state management
const gameState = {
  connected: false,
  currentView: 'joinView',
  currentGame: null,
  currentPlayer: null,
  players: [],
  messages: [],
  gameInProgress: false,
  nextGameTime: null,
  selectedVote: null,
  socket: null,
  userStats: {
    gamesPlayed: 0,
    gamesWon: 0,
    totalEarnings: 0
  },
  aiControlled: false,  // Tracks if the current player is AI-controlled
  submittedPrompt: null, // Tracks if the player submitted a prompt
  votingOpen: false,     // Tracks if voting phase is active
  gameResults: null,     // Stores the results of the game
};

// Connect to WebSocket server
function connectToServer() {
  updateConnectionStatus('connecting');
  
  try {
    // Close existing connection if any
    if (gameState.socket) {
      console.log("Closing existing connection before reconnecting");
      gameState.socket.close();
    }
    
    // Create new WebSocket connection
    gameState.socket = new WebSocket('ws://localhost:8765');
    
    // Connection opened
    gameState.socket.onopen = function(event) {
      console.log("Connected to WebSocket server");
      gameState.connected = true;
      updateConnectionStatus('online');
      
      // Send a ping to test connection
      sendToServer('ping', {});
      
      // Request current game state
      sendToServer('getState', {});
    };
    
    // Listen for messages
    gameState.socket.onmessage = function(event) {
      try {
        const data = JSON.parse(event.data);
        console.log("Received from server:", data);
        handleServerMessage(data);
      } catch (error) {
        console.error("Error parsing message from server:", error);
      }
    };
    
    // Connection closed
    gameState.socket.onclose = function(event) {
      console.log("WebSocket connection closed:", event);
      gameState.connected = false;
      updateConnectionStatus('offline');
      
      // Try to reconnect after a delay
      setTimeout(connectToServer, 3000);
    };
    
    // Connection error
    gameState.socket.onerror = function(error) {
      console.error("WebSocket error:", error);
      updateConnectionStatus('offline');
    };
    
  } catch (error) {
    console.error("Connection error:", error);
    updateConnectionStatus('offline');
  }
}

// Send messages to the server
function sendToServer(messageType, messageData) {
  if (!gameState.connected || !gameState.socket) {
    showToast('error', 'Not connected to server');
    return false;
  }
  
  try {
    const payload = {
      type: messageType,
      ...messageData
    };
    console.log("Sending to server:", payload);
    gameState.socket.send(JSON.stringify(payload));
    return true;
  } catch (error) {
    console.error("Error sending message:", error);
    return false;
  }
}

// Handle messages from the server
function handleServerMessage(data) {
  console.log(`Processing ${data.type} message:`, data);
  
  switch(data.type) {
    case "gameState":
      // Update our local game state with server data
      if (data.data) {
        if (Array.isArray(data.data.players)) {
          console.log(`Updating players from ${gameState.players.length} to ${data.data.players.length}`);
          gameState.players = data.data.players;
          
          // Check if current player is AI-controlled
          if (gameState.currentPlayer) {
            const currentPlayerData = gameState.players.find(p => p.id === gameState.currentPlayer.id);
            gameState.aiControlled = currentPlayerData && currentPlayerData.isAI === true;
          }
        }
        
        gameState.gameInProgress = data.data.gameInProgress;
        gameState.nextGameTime = data.data.nextGameTime;
        gameState.currentGame = data.data.currentGameId;
        gameState.votingOpen = data.data.votingOpen;
        gameState.gameResults = data.data.gameResults;
        
        // If voting is open, move to voting view
        if (gameState.votingOpen && gameState.currentView !== 'votingView') {
          startVoting();
        }
        
        // If results are available and game is not in progress, show results
        if (gameState.gameResults && !gameState.gameInProgress && gameState.currentView !== 'resultsView') {
          showResults();
        }
        
        // Update UI with new data
        updateAllPlayerLists();
        updateGameCounters();
        updateNextGameCountdown();
        
        // Update create game button
        updateCreateGameButton();
      }
      break;
      
    case "playersUpdate":
      // Update player list
      if (Array.isArray(data.players)) {
        console.log(`Updating players from ${gameState.players.length} to ${data.players.length}`);
        gameState.players = data.players;
        
        // Update UI with new player data
        updateAllPlayerLists();
        updateGameCounters();
      }
      break;
      
    case "newMessage":
      // Add message to chat
      if (data.message && data.message.senderId) {
        const player = gameState.players.find(p => p.id === data.message.senderId);
        if (player) {
          addMessage(player, data.message.text);
        }
      }
      break;
      
    case "pong":
      console.log("Server responded to ping");
      break;
      
    default:
      console.log("Unknown message type received:", data.type);
  }
}

// Update connection status display
function updateConnectionStatus(status) {
  const statusEl = document.getElementById('connectionStatus');
  statusEl.className = 'connection-status ' + status;
  
  switch(status) {
    case 'online':
      statusEl.textContent = 'Connected';
      break;
    case 'offline':
      statusEl.textContent = 'Disconnected';
      gameState.connected = false;
      
      // Auto-reconnect attempt
      setTimeout(connectToServer, 3000);
      break;
    case 'connecting':
      statusEl.textContent = 'Connecting...';
      break;
  }
}

// Update all player lists throughout UI
function updateAllPlayerLists() {
  updateLobbyPlayers();
  updateWaitingPlayers();
  updateCurrentPlayers();
}

// Update game counters (player count, prize pool, etc.)
function updateGameCounters() {
  // Update prize pool (10 USDC per player)
  const poolAmount = gameState.players.length * 10;
  
  // Update lobby view counters
  const prizePoolAmount = document.getElementById('prizePoolAmount');
  if (prizePoolAmount) {
    prizePoolAmount.textContent = poolAmount;
  }
  
  const lobbyPlayerCount = document.getElementById('lobbyPlayerCount');
  if (lobbyPlayerCount) {
    lobbyPlayerCount.textContent = gameState.players.length;
  }
  
  const upcomingGameId = document.getElementById('upcomingGameId');
  if (upcomingGameId) {
    upcomingGameId.textContent = gameState.currentGame || "4281";
  }
  
  // Update waiting room counters
  const waitingPrizePool = document.getElementById('waitingPrizePool');
  if (waitingPrizePool) {
    waitingPrizePool.textContent = poolAmount;
  }
  
  const waitingPlayerCount = document.getElementById('waitingPlayerCount');
  if (waitingPlayerCount) {
    waitingPlayerCount.textContent = gameState.players.length;
  }
}

// Update lobby players list
function updateLobbyPlayers() {
  const lobbyPlayersEl = document.getElementById('lobbyPlayers');
  if (!lobbyPlayersEl) return;
  
  console.log(`Updating lobby players list with ${gameState.players.length} players`);
  lobbyPlayersEl.innerHTML = '';
  
  // Show up to 6 players in the lobby preview
  const playersToShow = gameState.players.slice(0, Math.min(6, gameState.players.length));
  
  if (playersToShow.length === 0) {
    lobbyPlayersEl.innerHTML = '<div class="player-card"><div class="player-name">No players yet</div></div>';
    return;
  }
  
  playersToShow.forEach(player => {
    const playerCard = document.createElement('div');
    playerCard.classList.add('player-card');
    
    // Check if this is the current user
    if (gameState.currentPlayer && player.id === gameState.currentPlayer.id) {
      playerCard.classList.add('you');
    }
    
    const initials = player.initials || player.name.substring(0, 2).toUpperCase();
    
    playerCard.innerHTML = `
      <div class="avatar">${initials}</div>
      <div class="player-name">${player.name}${gameState.currentPlayer && player.id === gameState.currentPlayer.id ? ' (You)' : ''}</div>
    `;
    
    lobbyPlayersEl.appendChild(playerCard);
  });
}

// Update waiting room players list
function updateWaitingPlayers() {
  const waitingPlayersEl = document.getElementById('waitingPlayers');
  if (!waitingPlayersEl) return;
  
  console.log(`Updating waiting players list with ${gameState.players.length} players`);
  waitingPlayersEl.innerHTML = '';
  
  if (gameState.players.length === 0) {
    waitingPlayersEl.innerHTML = '<div class="player-card"><div class="player-name">No players yet</div></div>';
    return;
  }
  
  gameState.players.forEach(player => {
    const playerCard = document.createElement('div');
    playerCard.classList.add('player-card');
    
    // Check if this is the current user
    if (gameState.currentPlayer && player.id === gameState.currentPlayer.id) {
      playerCard.classList.add('you');
    }
    
    const initials = player.initials || player.name.substring(0, 2).toUpperCase();
    
    playerCard.innerHTML = `
      <div class="avatar">${initials}</div>
      <div class="player-name">${player.name}${gameState.currentPlayer && player.id === gameState.currentPlayer.id ? ' (You)' : ''}</div>
    `;
    
    waitingPlayersEl.appendChild(playerCard);
  });
}

// Update current players list (during game)
function updateCurrentPlayers() {
  const currentPlayersEl = document.getElementById('currentPlayers');
  if (!currentPlayersEl) return;
  
  currentPlayersEl.innerHTML = '';
  
  if (gameState.players.length === 0) {
    currentPlayersEl.innerHTML = '<div class="player-card"><div class="player-name">No players yet</div></div>';
    return;
  }
  
  gameState.players.forEach(player => {
    const playerCard = document.createElement('div');
    playerCard.classList.add('player-card');
    
    // Check if this is the current user
    if (gameState.currentPlayer && player.id === gameState.currentPlayer.id) {
      playerCard.classList.add('you');
    }
    
    const initials = player.initials || player.name.substring(0, 2).toUpperCase();
    
    playerCard.innerHTML = `
      <div class="avatar">${initials}</div>
      <div class="player-name">${player.name}${gameState.currentPlayer && player.id === gameState.currentPlayer.id ? ' (You)' : ''}</div>
    `;
    
    currentPlayersEl.appendChild(playerCard);
  });
}

// Update next game countdown timer
function updateNextGameCountdown() {
  if (!gameState.nextGameTime) return;
  
  const now = new Date().getTime();
  const timeLeft = Math.max(0, gameState.nextGameTime - now);
  
  const minutes = Math.floor(timeLeft / (60 * 1000));
  const seconds = Math.floor((timeLeft % (60 * 1000)) / 1000);
  
  const timeString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
  
  // Update various timer displays
  const nextGameTimer = document.getElementById('nextGameTimer');
  if (nextGameTimer) {
    nextGameTimer.textContent = `Next Game: ${timeString}`;
  }
  
  const nextGameCountdown = document.getElementById('nextGameCountdown');
  if (nextGameCountdown) {
    nextGameCountdown.textContent = timeString;
  }
  
  // If in waiting room, update that timer too
  if (gameState.currentView === 'waitingView') {
    const waitingTimer = document.getElementById('waitingTimer');
    if (waitingTimer) {
      waitingTimer.textContent = `Starting in: ${timeString}`;
    }
    
    // Update progress bar
    const maxWaitTime = 3 * 60 * 1000; // 3 minutes
    const elapsedPercent = ((maxWaitTime - timeLeft) / maxWaitTime) * 100;
    const waitingProgress = document.getElementById('waitingProgress');
    if (waitingProgress) {
      waitingProgress.style.width = `${elapsedPercent}%`;
    }
  }
  
  // Check if game should start
  if (timeLeft <= 0 && gameState.currentView === 'waitingView') {
    startGame();
  }
}

// Join the game as a player
function joinGame(type) {
  const username = document.getElementById('username').value;
  const wallet = document.getElementById('wallet').value;
  const prompt = document.getElementById('promptText').value;
  
  if (!username || !wallet || !prompt) {
    showToast('error', 'Please fill in all fields');
    return;
  }
  
  closeModal('human');
  showToast('info', 'Processing join request...', 1500);
  
  // Submit the prompt
  sendToServer('submitPrompt', { prompt: prompt });
  gameState.submittedPrompt = prompt;
  
  // Create player object
  const initials = username.substring(0, 2).toUpperCase();
  gameState.currentPlayer = {
    id: generateUniqueId(),
    name: username,
    walletAddress: wallet,
    initials: initials,
    type: 'human',
    votes: 0
  };
  
  // Send to server
  if (sendToServer('joinGame', { player: gameState.currentPlayer })) {
    console.log("Join request sent successfully");
    showToast('success', 'Joined game successfully!');
    
    // If no game in progress, create one
    if (!gameState.gameInProgress && gameState.nextGameTime > (new Date().getTime() + 25000)) {
      console.log("No game in progress, creating a new one");
      sendToServer('createGame', {});
    }
    
    // Move to waiting room
    startWaitingRoom();
  } else {
    showToast('error', 'Failed to join game. Please try again.');
  }
}

// Generate a unique ID for players
function generateUniqueId() {
  return 'id_' + Math.random().toString(36).substr(2, 9);
}

// Start waiting room view
function startWaitingRoom() {
  console.log(`Starting waiting room with ${gameState.players.length} players`);
  
  // Move to waiting room view
  showView('waitingView');
  
  // Update displays
  updateWaitingPlayers();
  updateGameCounters();
  updateNextGameCountdown();
  
  // Update game ID
  const waitingGameId = document.getElementById('waitingGameId');
  if (waitingGameId) {
    waitingGameId.textContent = gameState.currentGame || "4281";
  }
  
  // If a game is in progress, indicate waiting for next game
  const waitingStatus = document.getElementById('waitingStatus');
  if (waitingStatus) {
    if (gameState.gameInProgress) {
      waitingStatus.textContent = 'Waiting for next game...';
      document.getElementById('lateJoinNotification').style.display = 'block';
    } else {
      waitingStatus.textContent = 'Waiting for game to start...';
      document.getElementById('lateJoinNotification').style.display = 'none';
    }
  }
  
  // Start polling timer
  startTimerUpdates();
}

// Start a timer to update the UI every second
function startTimerUpdates() {
  // Clear any existing interval
  if (window.timerInterval) {
    clearInterval(window.timerInterval);
  }
  
  // Update timers every second
  window.timerInterval = setInterval(() => {
    updateNextGameCountdown();
  }, 1000);
}

// Start the game (chat phase)
function startGame() {
  // Update game state
  gameState.gameInProgress = true;
  gameState.messages = [];
  
  // Update game ID in chat
  document.getElementById('chatGameId').textContent = gameState.currentGame;
  
  // Move to chat view
  showView('chatView');
  
  // Show notification if player is AI-controlled
  if (gameState.aiControlled) {
    addSystemMessage('You have been selected as the AI-controlled player for this round. You cannot send messages, and the AI will chat on your behalf.');
    
    // Disable chat input
    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
      messageInput.disabled = true;
      messageInput.placeholder = "You're the AI player this round. The AI is sending messages for you...";
    }
    
    const sendBtn = document.querySelector('.send-btn');
    if (sendBtn) {
      sendBtn.disabled = true;
    }
  } else {
    addSystemMessage('Welcome to Game #' + gameState.currentGame + '! Chat for 1 minute. One player is controlled by AI - can you figure out who?');
  }
  
  // Set up countdown
  let seconds = 60; // Changed from longer time to exactly 1 minute
  const chatTimer = document.getElementById('chatTimer');
  const chatProgress = document.getElementById('chatProgress');
  
  const chatInterval = setInterval(() => {
    seconds--;
    chatTimer.textContent = `Time left: ${String(Math.floor(seconds / 60)).padStart(2, '0')}:${String(seconds % 60).padStart(2, '0')}`;
    
    // Update progress bar
    const progressPercent = (seconds / 60) * 100;
    chatProgress.style.width = `${progressPercent}%`;
    
    if (seconds <= 0) {
      clearInterval(chatInterval);
      // No need to call startVoting() here - server will handle game state transitions
    }
  }, 1000);
}

// Send a chat message
function sendMessage() {
  // Don't allow AI-controlled player to send messages
  if (gameState.aiControlled) {
    showToast('error', 'As the AI-controlled player, you cannot send messages this round');
    return;
  }
  
  const messageInput = document.getElementById('messageInput');
  const message = messageInput.value.trim();
  
  if (message && gameState.currentPlayer) {
    // Create message object
    const messageObj = {
      id: generateUniqueId(),
      senderId: gameState.currentPlayer.id,
      senderName: gameState.currentPlayer.name,
      text: message,
      timestamp: new Date().getTime()
    };
    
    // Send to server
    sendToServer('chatMessage', { message: messageObj });
    
    // Clear input
    messageInput.value = '';
  }
}

// Add a system message to the chat
function addSystemMessage(text) {
  const chatMessages = document.getElementById('chatMessages');
  const messageElement = document.createElement('div');
  messageElement.classList.add('message');
  
  messageElement.innerHTML = `
    <div class="message-avatar" style="background: linear-gradient(45deg, var(--accent), var(--primary))">SYS</div>
    <div class="message-content">
      <div class="message-sender">System</div>
      <div class="message-text">${text}</div>
    </div>
  `;
  
  chatMessages.appendChild(messageElement);
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

// Function to add a bot message using the OpenAI integration
function addBotMessage(botPlayer) {
  // Request a bot message from the server (which will use OpenAI)
  if (sendToServer('requestBotMessage', { botId: botPlayer.id })) {
    console.log(`Requested bot message for ${botPlayer.name}`);
  } else {
    console.log(`Failed to request bot message for ${botPlayer.name}`);
    
    // Fallback in case of connection issue
    const fallbackMessages = [
      "Hello everyone! Excited to play this game with you all.",
      "I've been playing games like this for years, they're always fun.",
      "Has anyone here tried the beta version? This is my first time.",
      "What's your strategy for identifying bots? I usually look for patterns in responses.",
      "I think we should all share something personal to prove we're human. I'll start: I have a cat named Pixel.",
      "The interface is really well designed. I like the color scheme.",
      "Anyone else from the East Coast? It's getting late here!",
      "I think one telltale sign of bots is that they respond too quickly sometimes."
    ];
    
    const randomMessage = fallbackMessages[Math.floor(Math.random() * fallbackMessages.length)];
    addMessage(botPlayer, randomMessage);
  }
}

// Add a message to the chat
function addMessage(player, text) {
  const chatMessages = document.getElementById('chatMessages');
  const messageElement = document.createElement('div');
  messageElement.classList.add('message');
  
  const isCurrentPlayer = gameState.currentPlayer && player.id === gameState.currentPlayer.id;
  const initials = player.initials || player.name.substring(0, 2).toUpperCase();
  
  messageElement.innerHTML = `
    <div class="message-avatar" style="background: ${isCurrentPlayer ? 'linear-gradient(45deg, var(--accent), var(--primary))' : 'linear-gradient(45deg, var(--primary), var(--secondary))'}">${initials}</div>
    <div class="message-content">
      <div class="message-sender">${player.name}${isCurrentPlayer ? '<span class="you-badge">You</span>' : ''}</div>
      <div class="message-text">${text}</div>
    </div>
  `;
  
  chatMessages.appendChild(messageElement);
  
  // Store message in state
  gameState.messages.push({
    id: generateUniqueId(),
    senderId: player.id,
    senderName: player.name,
    text: text,
    timestamp: new Date().getTime()
  });
  
  // Scroll to bottom
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

// Start the voting phase
function startVoting() {
  showView('votingView');
  populateVotingPlayers();
  
  // Set up countdown
  let seconds = 10;
  const votingTimer = document.getElementById('votingTimer');
  const votingProgress = document.getElementById('votingProgress');
  
  const votingInterval = setInterval(() => {
    seconds--;
    votingTimer.textContent = `Time left: 00:${String(seconds).padStart(2, '0')}`;
    
    // Update progress bar
    const progressPercent = (seconds / 10) * 100;
    votingProgress.style.width = `${progressPercent}%`;
    
    if (seconds <= 0) {
      clearInterval(votingInterval);
      showResults();
    }
  }, 1000);
}

// Populate the voting players list
function populateVotingPlayers() {
  const votingPlayers = document.getElementById('votingPlayers');
  votingPlayers.innerHTML = '';
  
  // Show all players except current player
  const playersToVoteOn = gameState.players.filter(p => !gameState.currentPlayer || p.id !== gameState.currentPlayer.id);
  
  if (playersToVoteOn.length === 0) {
    votingPlayers.innerHTML = '<div class="player-card"><div class="player-name">No other players to vote on</div></div>';
    return;
  }
  
  playersToVoteOn.forEach(player => {
    const playerCard = document.createElement('div');
    playerCard.classList.add('player-card');
    
    const initials = player.initials || player.name.substring(0, 2).toUpperCase();
    
    playerCard.innerHTML = `
      <div class="avatar">${initials}</div>
      <div class="player-name">${player.name}</div>
      <button class="vote-btn" onclick="voteForPlayer('${player.id}')">VOTE AS BOT</button>
    `;
    
    votingPlayers.appendChild(playerCard);
  });
}

// Vote for a player
function voteForPlayer(playerId) {
  // Don't allow AI-controlled player to vote
  if (gameState.aiControlled) {
    showToast('error', 'As the AI-controlled player, you cannot vote');
    return;
  }
  
  // Update UI
  document.querySelectorAll('.vote-btn').forEach(btn => {
    btn.classList.remove('selected');
  });
  
  const voteButtons = document.querySelectorAll('.vote-btn');
  for (let i = 0; i < voteButtons.length; i++) {
    if (voteButtons[i].onclick.toString().includes(`'${playerId}'`)) {
      voteButtons[i].classList.add('selected');
      break;
    }
  }
  
  // Store vote in state
  gameState.selectedVote = playerId;
  
  // Send vote to server
  sendToServer('vote', { voterId: gameState.currentPlayer.id, votedForId: playerId });
  
  const votedPlayer = gameState.players.find(p => p.id === playerId);
  showToast('info', `You voted for ${votedPlayer ? votedPlayer.name : 'unknown player'}`);
}

// Show game results
function showResults() {
  showView('resultsView');
  
  // Simulate other player votes
  simulateVotes();
  
  // Display results
  displayResults();
  
  // Update player stats
  updatePlayerStats();
  
  // Update game state for next game
  prepareForNextGame();
}

// Simulate votes from other players
function simulateVotes() {
  // Each player votes for someone they think is a bot
  gameState.players.forEach(voter => {
    // Skip if this is the current player or they already voted
    if (gameState.currentPlayer && voter.id === gameState.currentPlayer.id) return;
    
    const candidates = gameState.players.filter(p => p.id !== voter.id);
    let votedPlayer;
    
    if (Math.random() < 0.6) {
      // Try to vote for a bot player (simulate some intelligence)
      const botCandidates = candidates.filter(p => p.type === 'bot');
      if (botCandidates.length > 0) {
        votedPlayer = botCandidates[Math.floor(Math.random() * botCandidates.length)];
      }
    }
    
    // If no vote yet, vote randomly
    if (!votedPlayer && candidates.length > 0) {
      votedPlayer = candidates[Math.floor(Math.random() * candidates.length)];
    }
    
    if (votedPlayer) {
      votedPlayer.votes = (votedPlayer.votes || 0) + 1;
    }
  });
}

// Display game results
function displayResults() {
  const resultsGrid = document.getElementById('resultsGrid');
  resultsGrid.innerHTML = '';
  
  if (!gameState.gameResults) {
    resultsGrid.innerHTML = '<div class="result-card"><div class="player-name">Results not available</div></div>';
    return;
  }
  
  // Extract info from game results
  const { aiPlayerId, aiPlayerName, mostVotedPlayerId, mostVotedPlayerName, correctIdentification, voteCounts } = gameState.gameResults;
  
  // Create results cards
  gameState.players.forEach(player => {
    const resultCard = document.createElement('div');
    resultCard.classList.add('result-card');
    
    // Highlight AI player
    if (player.id === aiPlayerId) {
      resultCard.classList.add('bot');
    } else {
      resultCard.classList.add('human');
    }
    
    // Highlight current player
    if (gameState.currentPlayer && player.id === gameState.currentPlayer.id) {
      resultCard.classList.add('you');
    }
    
    // Highlight most voted player
    const isMostVoted = player.id === mostVotedPlayerId;
    
    const initials = player.initials || player.name.substring(0, 2).toUpperCase();
    const voteCount = voteCounts[player.id] || 0;
    
    resultCard.innerHTML = `
      <div class="avatar">${initials}</div>
      <div class="player-name">${player.name}${gameState.currentPlayer && player.id === gameState.currentPlayer.id ? ' (You)' : ''}</div>
      <div class="result-label ${player.id === aiPlayerId ? 'bot' : 'human'}">${player.id === aiPlayerId ? 'AI PLAYER' : 'HUMAN'}</div>
      ${isMostVoted ? '<div class="most-voted">Most Voted</div>' : ''}
      <div class="votes-count">${voteCount} vote${voteCount !== 1 ? 's' : ''}</div>
    `;
    
    resultsGrid.appendChild(resultCard);
  });
  
  // Show outcome at the top
  const resultsTitle = document.querySelector('.results-title');
  const resultsSubtitle = document.querySelector('.voting-subtitle');
  
  if (correctIdentification) {
    resultsTitle.textContent = "The AI Was Found!";
    resultsSubtitle.textContent = `${mostVotedPlayerName} received the most votes and was indeed the AI player.`;
  } else {
    resultsTitle.textContent = "The AI Got Away!";
    resultsSubtitle.textContent = `${mostVotedPlayerName} was voted as the AI, but the real AI was ${aiPlayerName}.`;
  }
}

// Update player stats display
function updatePlayerStats() {
  // Update games played
  gameState.userStats.gamesPlayed++;
  
  // Calculate win rate
  const winRate = gameState.userStats.gamesPlayed > 0 
    ? Math.round((gameState.userStats.gamesWon / gameState.userStats.gamesPlayed) * 100) 
    : 0;
  
  // Update UI
  document.getElementById('playerEarnings').textContent = gameState.userStats.totalEarnings;
  document.getElementById('playerWinRate').textContent = winRate + '%';
  document.getElementById('playerGamesPlayed').textContent = gameState.userStats.gamesPlayed;
}

// Prepare for the next game
function prepareForNextGame() {
  // Reset votes
  gameState.players.forEach(player => {
    player.votes = 0;
  });
  
  gameState.selectedVote = null;
  
  // Set next game time
  const now = new Date().getTime();
  gameState.nextGameTime = now + 3 * 60 * 1000; // 3 minutes from now
  
  // Create new game ID
  gameState.currentGame = "G" + Math.floor(Math.random() * 10000);
  
  // Game is now preparing for next round, not in progress
  gameState.gameInProgress = false;
}

// Play another game
function playAgain() {
  // Go to waiting room for next game
  startWaitingRoom();
}

// Show a specific view/screen
function showView(viewId) {
  // Hide all views
  document.querySelectorAll('.view').forEach(view => {
    view.classList.remove('active');
  });
  
  // Show the requested view
  document.getElementById(viewId).classList.add('active');
  gameState.currentView = viewId;
}

// Modal management
function openModal(type) {
  if (type === 'human') {
    document.getElementById('humanModal').classList.add('active');
  } else {
    document.getElementById('botModal').classList.add('active');
  }
}

function closeModal(type) {
  if (type === 'human') {
    document.getElementById('humanModal').classList.remove('active');
  } else if (type === 'bot') {
    document.getElementById('botModal').classList.remove('active');
  } else if (type === 'prompt') {
    document.getElementById('promptModal').classList.remove('active');
  }
}

// Toast notifications
function showToast(type, message, duration = 3000) {
  const toastContainer = document.getElementById('toastContainer');
  
  const toast = document.createElement('div');
  toast.classList.add('toast', type);
  toast.innerHTML = `
    ${message}
    <button class="toast-close" onclick="this.parentElement.remove()">×</button>
  `;
  
  toastContainer.appendChild(toast);
  
  // Show animation
  setTimeout(() => {
    toast.classList.add('show');
  }, 10);
  
  // Auto remove
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => {
      toast.remove();
    }, 300);
  }, duration);
}

// Add a debug reset function
function resetServer() {
  if (gameState.connected && gameState.socket) {
    console.log("Sending reset request to server");
    sendToServer('reset', {});
    
    // Clear local state as well
    gameState.players = [];
    updateAllPlayerLists();
    updateGameCounters();
    
    // Show toast
    showToast('info', 'Server has been reset', 2000);
  } else {
    showToast('error', 'Not connected to server', 2000);
  }
}

function submitPrompt() {
  const promptText = document.getElementById('promptText').value.trim();
  
  if (!promptText) {
    showToast('error', 'Please enter a prompt');
    return;
  }
  
  if (sendToServer('submitPrompt', { prompt: promptText })) {
    gameState.submittedPrompt = promptText;
    showToast('success', 'Prompt submitted successfully!');
    closeModal('prompt');
    
    // Update UI to show submitted prompt
    const submitPromptBtn = document.getElementById('submitPromptBtn');
    if (submitPromptBtn) {
      submitPromptBtn.innerHTML = 'Prompt Submitted ✓';
      submitPromptBtn.disabled = true;
      submitPromptBtn.classList.add('success-btn');
    }
  } else {
    showToast('error', 'Failed to submit prompt');
  }
}

function updateCreateGameButton() {
  const createGameBtn = document.getElementById('createGameBtn');
  if (createGameBtn) {
    const hasEnoughPlayers = gameState.players.length >= 2;
    createGameBtn.disabled = !hasEnoughPlayers || gameState.gameInProgress;
    
    if (!hasEnoughPlayers) {
      createGameBtn.textContent = "Create Game (Need at least 2 players)";
    } else if (gameState.gameInProgress) {
      createGameBtn.textContent = "Game in Progress...";
    } else {
      createGameBtn.textContent = "Create New Game";
    }
  }
}

// Clean up when leaving
window.addEventListener('beforeunload', function() {
  // Send a message to server that we're leaving
  if (gameState.connected && gameState.socket && gameState.currentPlayer) {
    try {
      sendToServer('playerLeft', { playerId: gameState.currentPlayer.id });
    } catch (e) {
      console.error("Error sending playerLeft message:", e);
    }
  }
  
  // Clear any intervals
  if (window.timerInterval) {
    clearInterval(window.timerInterval);
  }
});

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
  // Connect to server
  connectToServer();
  
  // Add debug button
  const debugButton = document.createElement('button');
  debugButton.innerText = 'Reset Server';
  debugButton.onclick = resetServer;
  debugButton.style = 'position: fixed; top: 10px; left: 10px; background: #ff2a6d; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;';
  document.body.appendChild(debugButton);
  
  // Add event listeners for form submissions
  const messageInput = document.getElementById('messageInput');
  if (messageInput) {
    messageInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        sendMessage();
      }
    });
  }
  
  const usernameInput = document.getElementById('username');
  if (usernameInput) {
    usernameInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        joinGame('human');
      }
    });
  }
  
  const botnameInput = document.getElementById('botname');
  if (botnameInput) {
    botnameInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        joinGame('bot');
      }
    });
  }
  
  // Start timer updates
  startTimerUpdates();
});
    </script>
   </body>
</html>